
<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

- [Recursive Call](#recursive-call)
  - [재귀 호출의 구성 요소](#재귀-호출의-구성-요소)
  - [재귀 호출의 동작 원리](#재귀-호출의-동작-원리)
  - [재귀 호출의 예제](#재귀-호출의-예제)
  - [재귀 호출의 장단점](#재귀-호출의-장단점)
    - [장점](#장점)
    - [단점](#단점)
  - [재귀 호출을 사용할 때 주의할 점](#재귀-호출을-사용할-때-주의할-점)
- [Memoization](#memoization)

<!-- TOC end -->

# Recursive Call

> 💡 함수가 자기 자신을 호출하는 프로그래밍 기법. 이 기법은 문제를 더 작은 동일한 문제로 나누어 해결할 때 유용하게 사용됨. 재귀 호출을 사용하는 문제들은 종종 문제를 분할하여 해결할 수 있는 구조를 가짐.


- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 **크기를 줄이**고 **간단하게 작성** 가능

## 재귀 호출의 구성 요소

1. 기저 사례 Base Case
    - 재귀 함수가 호출을 종료하는 조건
    - 기저 사례가 없으면 함수는 무한히 호출되어 프로그램이 멈추지 않게 됨
    - 기저 사례는 일반적으로 가장 간단하고 해결하기 쉬운 문제를 정의
2. 재귀 사례 Recursive Case
    - 문제를 더 작은 문제로 나누어 재귀적으로 해결하는 부분
    (마지막에 구한 하위 값을 이용하여 상위 값을 구하는 작업을 반복)
    - 함수는 자기 자신을 호출하여 문제를 점진적으로 단순화

## 재귀 호출의 동작 원리

- 재귀 함수는 함수 호출 스택을 이용하여 각 호출을 관리
- 함수가 자기 자신을 호출하면 새로운 스택 프레임이 생김
- **각 스택 프레임**은 **함수 호출의 상태**와 **로컬 변수**를 저장함
- 기저 사례에 도달하면 재귀 호출이 종료되고, 각 스택 프레임은 차례로 반환되면서 문제의 해답을 결합.

## 재귀 호출의 예제

1. 팩토리얼 계산
    1. 팩토리얼은 다음과 같은 수학적 정의를 가짐
        - `n! = n × (n-1)!` (n > 0)
        - `0! = 1`
    2. 재귀적 표현
        
        ```python
        def factorial(n):
            if n == 0:  # 기저 사례
                return 1
            else:  # 재귀 사례
                return n * factorial(n - 1)
        ```
        
        <p align = 'center'>
          <image src = '..\image\stack-rc1.png' width = 400>
        </p>
        
2. 피보나치 수열 계산
    1. 피보나치 수열은 다음과 같은 정의를 가짐
        - `F(n) = F(n-1) + F(n-2)` (n > 1)
        - `F(0) = 0`
        - `F(1) = 1`
    2. 재귀적 표현
        
        ```python
        def fibonacci(n):
            if n == 0:  # 기저 사례
                return 0
            elif n == 1:  # 기저 사례
                return 1
            else:  # 재귀 사례
                return fibonacci(n - 1) + fibonacci(n - 2)
        
        ```
3. 모든 배열 원소에 접근하기
    
  <p align = 'center'>
    <image src = '..\image\stack-rc2.png' width = 100>
  </p>

  <p align = 'center'>
    <image src = '..\image\stack-rc3.png' width = 400>
  </p>
  
    
    ```python
    
    def f(i, n):
        # i 접근할 원소 인덱스, n 크기
        # 현재와 목표를 매개변수로 둠
        if i == n:
            return
        else:
            print(arr[i])
            f(i+1, n)
            return
    
    arr = [1, 2, 3]
    n = 3
    f(0, n)
    
    # 1
    # 2
    # 3
    ```
    
1. 배열에 v가 있으면 1, 없으면 0을 리턴
    
  <p align = 'center'>
    <image src = '..\image\stack-rc4.png' width = 400>
  </p>
    
    ```python
    
    def f(i, n, v):
        # i 접근할 원소 인덱스, n 크기, v 찾는 값
        # 현재와 목표를 매개변수로 둠
        if i == n:
            return 0
        elif arr[i] == v:
            return 1
        else:
            return f(i+1, n, v)
    
    arr = [1, 2, 3]
    n = 3
    print(f(0, n, 2)) # 1
    ```
    

## 재귀 호출의 장단점

### 장점

- **문제 해결의 단순화** : 복잡한 문제를 더 간단한 하위 문제로 나누어 해결할 수 있음
- **코드의 가독성**: 문제에 대한 자연스러운 표현이 가능하여 코드가 더 직관적

### 단점

- **성능 문제** : 재귀 호출은 함수 호출 스택을 사용하므로 메모리와 시간이 많이 소모될 수 있음. 특히 비효율적인 재귀 호출(예: 중복 계산이 많은 피보나치 수열)은 성능 문제를 일으킬 수 있음
- **스택 오버플로우** : 재귀 호출이 너무 깊어지면 스택 오버플로우가 발생할 수 있음. 이는 호출이 너무 많이 중첩되어 스택 메모리를 초과할 때 발생.

## 재귀 호출을 사용할 때 주의할 점

1. 기저 사례 정의
    1. 항상 종료 조건을 명확히 정의하여 무한 재귀 호출을 방지
2. 성능 고려
    1. 재귀 호출을 사용하는 경우, 문제의 크기에 따라 성능이 급격히 떨어질 수 있으므로 메모리와 시간 효율성을 고려해야 함.
    2. 경우에 따라 반복문을 사용하는 것이 더 나은 선택
3. 최적화 기법 → 중복 계산을 방지하고 성능 개선
    1. Momoization 메모이제이션
    2. DP 동적 프로그래밍
- [참고] pypy, py에 따라 표현할 수 있는 게 다름!
    - pypy가 더 깊이 표현이 가능함

재귀 호출은 강력한 프로그래밍 기법이지만, 적절히 사용하지 않으면 성능 문제를 일으킬 수 있으므로 신중하게 설계하는 것이 중요


# Memoization

- 컴퓨터 과학에서 성능을 향상시키기 위한 기법으로, 특히 **재귀 호출이 많은 알고리즘에서 유용**하게 사용

- 이 기법의 기본 아이디어는 이미 계산한 결과를 저장해두고, 동일한 계산이 필요할 때 다시 계산하지 않고 저장된 결과를 재사용하는 것입니다.  
    > = 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인   실행속도를 빠르게 하는 기술 ⇒ 동적 계획법의 핵심이 되는 기술

  - **문제의 정의**  
    : 주로 문제를 작은 하위 문제로 나누어 해결하는 알고리즘에서 사용됩니다. 예를 들어, **피보나치 수열**이나 **동적 계획법**(Dynamic Programming) 문제에서 자주 사용
  - **캐시 저장**  
    : 각 하위 문제의 결과를 저장할 캐시(주로 해시 테이블이나 배열 형태)를 사용합니다. 이 캐시를 통해 이미 계산된 값을 저장해 두고, 같은 하위 문제를 다시 해결할 때 저장된 값을 즉시 반환
  - **계산 최적화**  
    : 메모이제이션을 사용하면 중복된 계산을 피할 수 있기 때문에 알고리즘의 시간 복잡도를 줄일 수 있습니다.   
    예를 들어, 피보나치 수열의 경우, 메모이제이션 없이 단순 재귀 호출을 사용하면 지수 시간 복잡도가 발생하지만, 메모이제이션을 사용하면 선형 시간 복잡도로 해결할 수 있음.

- Memoization = To put in Memory : 메모리에 넣기
    - 기억되어야 할 것이라는 뜻의 라틴어 memorandum에서 파생되었다. 흔히 ‘기억하기’, ‘암기하기’라는 뜻의 memorization과 혼동하지만, 정확한 단어는 memoization이며 동사형은 memoize다

- 구현 방법
  - **Top-Down Approach**
    : 주어진 문제를 재귀적으로 해결하면서 하위 문제의 결과를 캐시에 저장
  - **Bottom-Up Approach**  
    : 하위 문제부터 시작하여 차례대로 문제를 해결해 나가면서 결과를 저장합니다. 이 방식은 보통 반복문을 사용하여 구현
- 예시 : 피보나치 수열
    - 피보나치 수를 구하는 함수를 재귀함수로 구현한 알고리즘의 경우 ‘엄청난 중복 호출이 존재한다’는 문제점이 있다
        
        <p align = 'center'>
        <image src = '..\image\stack-memoization.png' width = 400>
        </p>
        
        
        fibo(n)의 값을 계산하자마자 저장하면(=memoize), 실행시간을 Θ(n)으로 줄일 수 있다.
    ```py
    # DP의 구현 방식 1 : Recursive 방식
    # memo를 위한 배열을 할당하고, 모두 0으로 초기화
    # memo[0]을 0으로 memo[1]는 1로 초기화 한다.

    def fibo1(n):
            global memo
            if n >= 2 and memo[n] == 0:
                    memo[n] = fibo1(n-1) + fibo1(n-2)
            return memo[n]
    memo = [0] * (n+1)
    memo[0] = 0
    memo[1] = 1
    ```
    ```py
    def fib(n, memo={}):
        if n in memo:
            return memo[n]
        if n <= 1:
            return n
        memo[n] = fib(n-1, memo) + fib(n-2, memo)
        return memo[n]

    print(fib(10))  # Output: 55
    ```