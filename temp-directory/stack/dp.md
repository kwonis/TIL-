<!-- TOC start (generated with https://github.com/derlin/bitdowntoc) -->

- [동적 계획법(DP; Dynamic Programming)](#동적-계획법dp-dynamic-programming)
      + [일반적인 절차](#일반적인-절차)
      + [동적 계획법의 접근 방식](#동적-계획법의-접근-방식)
      + [DP 예제 - 피보나치 수열](#dp-예제---피보나치-수열)
      + [DP의 구현 방식](#dp의-구현-방식)
      + [동적 계획법의 활용 예시](#동적-계획법의-활용-예시)

<!-- TOC end -->


# 동적 계획법(DP; Dynamic Programming)

> 💡 복잡한 문제를 해결하기 위해 사용되는 알고리즘 기법
그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘


- 문제를 여러 하위 문제로 나누어 해결하고, 하위 문제의 해답을 조합하여 원래 문제를 해결하는 방식
  - 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘
- 동적 계획법의 주요 속성
  - **중복되는 하위 문제** : 원래 문제를 해결하기 위해 같은 하위 문제를 여러 번 계산해야 할 때
  - **최적 부분 구조**  : 원래 문제의 최적해가 하위 문제의 최적해로 구성될 때
- 동적 계획법의 핵심 아이디어는 **메모이제이션**을 사용하여 하위 문제의 해답을 저장해 두고, 같은 하위 문제를 다시 계산하지 않고 저장된 결과를 재사용하는 것

### 일반적인 절차

1. 문제 정의   
: 문제를 해결하기 위한 함수와 그 함수가 반환해야 하는 결과를 정의
2. 하위 문제 정의  
: 문제를 해결하기 위한 하위 문제를 정의하고, 각 하위 문제의 해답이 무엇인지 결정
3. 메모이제이션 또는 테이블 구축  
: 하위 문제의 결과를 저장하기 위한 방법을 결정.  
메모이제이션(탑다운 접근 방식) 또는 테이블 기반 접근 방식(바텀업 접근 방식)을 사용할 수 있음
4. 최적 해답 구성  
: 하위 문제의 결과를 조합하여 원래 문제의 최적 해답을 구성

### 동적 계획법의 접근 방식

- **탑다운 방식 (Memoization)**:
  - 재귀적으로 문제를 해결하면서, 하위 문제의 결과를 저장
  - 이미 계산된 결과는 캐시에서 가져와서 중복 계산을 피함
- **바텀업 방식 (Tabulation)**:
  - 하위 문제부터 시작하여 점진적으로 문제를 해결
  - 테이블(보통 배열이나 행렬)을 사용하여 하위 문제의 결과를 저장하고, 이를 이용해 더 큰 문제를 해결합니다.

### DP 예제 - 피보나치 수열

1. 문제 정의 : 피보나치 수열의 n번째 항을 구하는 문제
2. 하위 문제 정의 : F(n) = F(n-1) + F(n-2) 를 계산
    1. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구함
    2. 그 결과를 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구함
        
    <p align = 'center'>
    <image src = '..\image\stack-dp1.png' width = 300>
    </p>
    
        
    
    ```python
    # DP의 구현 방식 2 : Iterative 방식
    def fibo2(n):
    		f = [0] * (n+1)
    		f[0] = 0
    		f[1] = 1
    		for i in range(2, n+1):
    				f[i] = f[i-1] + f[i-2]
    		
    		return f[n]
    ```
    
3. Top-Down Approach
    
    ```python
    def fib(n, memo={}):
        if n in memo:
            return memo[n]
        if n <= 1:
            return n
        memo[n] = fib(n-1, memo) + fib(n-2, memo)
        return memo[n]
    ```
    
4. Bottom-Up Approach
    
    ```python
    def fib(n):
        if n <= 1:
            return n
        dp = [0] * (n + 1)
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
    ```
    

### DP의 구현 방식

- **recursive 방식 (예시 - fibo1())**
- **iterative 방식 (예시 - fibo2())**

memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다.

재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.

### 동적 계획법의 활용 예시

- **최단 경로 문제**: 다익스트라 알고리즘, 벨만-포드 알고리즘.
- **최적화 문제**: 배낭 문제, 최장 공통 부분 수열(Longest Common Subsequence).
- **계획 문제**: 작업 스케줄링, 자원 할당 문제

동적 계획법은 효율적인 문제 해결을 위한 강력한 도구이며, 복잡한 문제를 보다 간결하고 최적화된 방법으로 해결할 수 있게 해줍니다.